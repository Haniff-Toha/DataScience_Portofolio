# -*- coding: utf-8 -*-
"""Product Recomendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IgIa8AN8zOehIE9BvKtrRb6GIu98F0ij

# Product Recomendation System

**Melakukan impolrt library/package yang digunakan dalam projek**
"""

# Import package dan library yang digunakan dalam projek
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import math

#library untuk melakukan CBF
from sklearn.feature_extraction.text import TfidfVectorizer #Untuk melakukan vektorisasi
from sklearn.metrics.pairwise import cosine_similarity # untuk menghitung Cosine Similiarity

# Library untuk Collaborative Filtering dengan Metrix Factorization
from scipy.sparse.linalg import svds

# Library untuk melakukan evaluasi
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error

"""# Data Overview

**Blok Kode dibawah dilakukan untuk melakukan load dataset product serta menampilkannya dalam format dataframe**
"""

product = pd.read_csv('product.csv')
product

"""Blok Kode dibawah dilakukan untuk meninjau kolom dari dataframe product. Langkah ini penting untuk analisis lebih lanjut"""

product.info()

"""**Blok Kode dibawah dilakukan untuk melakukan load dataset user_reviews serta menampilkannya dalam format dataframe**"""

user_reviews = pd.read_csv("user_reviews.csv")
user_reviews

"""Blok Kode dibawah dilakukan untuk meninjau kolom dari dataframe user_reviews. Langkah ini penting untuk analisis lebih lanjut"""

user_reviews.info()

"""# Exploratory Data Analysis

## Deskripsi Statistik

Blok kode dibawah ditujukan untuk melakukan overview data yang terdapat dalam dataframe product. langkah ini penting untuk analisis lebih lanjut.
"""

hasil = []
for col in product.columns:
    hasil.append([col, product[col].dtype, product[col].isna().sum(), 100*product[col].isna().sum()/len(product[col]), product[col].nunique(), product[col].unique()[:4]])

##presentasi jumlah null, diguakan untuk feature selection (Biasanya diatas 5% dihapus *tergantung kesepakatan team)
output = pd.DataFrame(data=hasil, columns='kolom tipedata jumlahnull persenull jumlahunik contohunik'.split())
output

"""Blok kode dibawah ditujukan untuk melihat deskripsi statistik dari kolom numerikal dalam dataframe product"""

product.describe()

"""Blok kode dibawah ditujukan untuk melihat deskripsi statistik dari kolom kategorikal atau object dalam dataframe product"""

product.select_dtypes('object').describe().T

"""Blok kode dibawah ditujukan untuk melakukan overview data yang terdapat dalam dataframe user_reviews. langkah ini penting untuk analisis lebih lanjut."""

hasil = []
for col in user_reviews.columns:
    hasil.append([col, user_reviews[col].dtype, user_reviews[col].isna().sum(), 100*user_reviews[col].isna().sum()/len(user_reviews[col]), user_reviews[col].nunique(), user_reviews[col].unique()[:4]])

##presentasi jumlah null, diguakan untuk feature selection (Biasanya diatas 5% dihapus *tergantung kesepakatan team)
output = pd.DataFrame(data=hasil, columns='kolom tipedata jumlahnull persenull jumlahunik contohunik'.split())
output

"""Blok kode dibawah ditujukan untuk melihat deskripsi statistik dari kolom numerikal dalam dataframe user_reviews"""

user_reviews.describe()

"""Blok kode dibawah ditujukan untuk melihat deskripsi statistik dari kolom kategorikal atau object dalam dataframe user_reviews"""

user_reviews.select_dtypes('object').describe().T

"""## Univariate Analysis

### Produk

Blok kode dibawah ditujukan untuk meninjau kolom yang ada dalam dataframe product yang akan dipilih untuk dilakukan univariate analysis
"""

product.columns

"""Blok Kode dibawah ditujukan untuk melakukan visaulisasi terhadap data pada kolom 'rating' pada dataframe product untuk meninjau distribusi dari nilai rata rata rating produk"""

# Create a figure with 1 row and 2 columns
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 8))

# Boxplot on the left side
sns.boxplot(y=product['rating'], color='orange', linewidth=3, ax=axes[0])
axes[0].set_title(f'Boxplot of Averae Product Rating', fontsize=18)

# KDE plot on the right side
sns.kdeplot(x=product['rating'], ax=axes[1])

# Add mean and mode lines to the KDE plot
mean_val = product['rating'].mean()
mode_val = product['rating'].mode()[0]

axes[1].axvline(mean_val, color='r', linestyle='--', label=f'Mean: {mean_val:.2f}')
axes[1].axvline(mode_val, color='g', linestyle='-', label=f'Mode: {mode_val:.2f}')
axes[1].set_title(f'Distribution of Average Product Rating', fontsize=18)
axes[1].legend()

# Adjust layout
plt.tight_layout()
plt.show()

"""**Observasi:**
- Didapati adanya nilai distribusi right-skewed, dimana average rating untuk tiap produk paling banyak di-angka 4.8 sampai 5,  dengan nilai rata-rata 4.84 dan nilai paling banyak 4.9

- Rating rata-rata yang tinggi dan penyebaran yang sempit menunjukkan bahwa produk secara umum sangat disukai oleh pelanggan.

- Konsentrasi rating di sekitar nilai tertinggi mungkin menunjukkan adanya bias dalam ulasan atau kualitas produk yang konsisten baik.

Blok kode dibawah ditujukan untuk melakukan visualisasi terhadap kolom 'category' pda dataframe product. hal ini dilakukan untuk meninjau top category product yang paling banyak
"""

# Get the category counts in descending order
category_order = product['category'].value_counts().index

# Create the countplot with categories sorted by frequency
plt.figure(figsize=(12, 6))
ax = sns.countplot(x='category', data=product, palette='Set2', order=category_order)

# Add title and labels
plt.title('Product Category Frecuency', fontsize=18)
plt.xlabel('')
plt.ylabel('Count', fontsize=14)

# Rotate the x-axis labels for better visibility (if the category names are long)
plt.xticks(rotation=45, ha='right')

# Add value labels on top of each bar
for p in ax.patches:
    ax.text(
        p.get_x() + p.get_width() / 2,  # X position (center of each bar)
        p.get_height() + 0.2,  # Y position (slightly above the bar)
        f'{int(p.get_height())}',  # The value to display
        ha='center',  # Center the text horizontally
        fontsize=12,  # Font size
        color='black'  # Text color
    )

# Display the plot
plt.tight_layout()
plt.show()

"""**Observasi:**
- Kategori "Alat dan Mesin Pertanian" adalah yang paling banyak muncul dalam dataset, dengan total 33 produk. Diikuti oleh "Bibit dan Benih Tanaman" sebanyak 30 produk dan "Pupuk dan Nutrisi Tanaman" sebanyak 26 produk.
- Distribusi menurun: Jumlah produk dalam kategori lainnya menurun secara bertahap, dengan kategori paling sedikit adalah "Pestisida dan Obat Tanaman" yang hanya memiliki 5 produk.
- Ketimpangan Frekuensi: Kategori atas seperti "Alat dan Mesin Pertanian," "Bibit dan Benih Tanaman," dan "Pupuk dan Nutrisi Tanaman" mendominasi hampir setengah dari total produk dalam dataset.
Sebaliknya, kategori dengan frekuensi rendah seperti "Pestisida dan Obat Tanaman", "Perlengkapan Rumah Kaca dan Pembibitan," dan "Teknologi Pertanian" hanya memiliki sedikit produk, menunjukkan distribusi yang tidak seimbang antar kategori.
- Observasi Berdasarkan Tren Pasar: Kebutuhan tinggi untuk kategori alat dan benih. Dominasi kategori "Alat dan Mesin Pertanian" dan "Bibit dan Benih Tanaman" mencerminkan fokus utama pada produk yang mendukung proses pertanian langsung, seperti pengolahan lahan, pembibitan, dan penanaman.
- Rendahnya produk teknologi dan pestisida: Kategori seperti "Teknologi Pertanian" dan "Pestisida dan Obat Tanaman" memiliki frekuensi rendah, yang dapat menunjukkan permintaan pasar yang lebih kecil atau kurangnya penyediaan produk-produk ini dalam dataset.

### User Reviews

blok kode dibawah ditujukan untuk melakukan visualisasi kolom 'rating' dari dataframe user_reviews. Hal ini dilakukan untuk meninjau sebaran serta frekuensi rating yang diberikan customer
"""

# Create a figure with 1 row and 2 columns
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(18, 6))

axes[0] = sns.countplot(x='rating', data=user_reviews, ax=axes[0], palette='Set2')
axes[0].set_title('User Rating Frecuency', fontsize=16)
axes[0].set_xlabel('User Rating', fontsize=14)
axes[0].set_ylabel('Frequency', fontsize=14)

for p in axes[0].patches:
    axes[0].text(
        p.get_x() + p.get_width() / 2,  # X position (center of each bar)
        p.get_height() + 0.2,  # Y position (slightly above the bar)
        f'{int(p.get_height())}',  # The value to display
        ha='center',  # Center the text horizontally
        fontsize=12,  # Font size
        color='black'  # Text color
    )

# Right plot: Pie chart (showing the distribution of ratings)
rating_counts = user_reviews['rating'].value_counts()  # Count the occurrences of each rating
rating_labels = rating_counts.index  # Rating values (e.g., 1, 2, 3, 4, 5)
rating_sizes = rating_counts.values  # The count for each rating

# Plot the pie chart
axes[1].pie(rating_sizes, labels=rating_labels, autopct='%1.1f%%', startangle=90, colors=sns.color_palette('Set2', len(rating_sizes)))
axes[1].set_title('User Rating Distribution (Pie Chart)', fontsize=16)

# Display the plot
plt.tight_layout()
plt.show()

"""**Observasi:**
- Rating paling sering: Rating 5 adalah yang paling sering diberikan, dengan total 41.809 ulasan, mencerminkan sebagian besar pengguna sangat puas dengan produk.
- Rating kedua terbanyak: Rating 2 berada di posisi kedua dengan 37.036 ulasan, menunjukkan sejumlah besar ketidakpuasan pengguna.
- Rating netral: Rating 3 berada di tengah-tengah dengan 34.622 ulasan, mencerminkan pengalaman pengguna yang biasa saja.
- Rating jarang diberikan: Rating 1 adalah yang paling sedikit diberikan, hanya 208 ulasan, menunjukkan bahwa hanya sedikit pengguna yang memberikan penilaian terendah.
- Ketimpangan Distribusi: Sebagian besar ulasan berada di rating tinggi (5) dan rendah (2), menciptakan pola distribusi yang terpolarisasi. Jumlah ulasan dengan rating netral (3) hampir sama dengan rating 2 dan sedikit lebih rendah dibandingkan rating 4.
- Rating sangat rendah jarang terjadi: Rating 1 sangat jarang diberikan dibandingkan rating lainnya, yang menunjukkan bahwa mayoritas pengguna tidak memberikan ulasan negatif ekstrim.

- Observasi Berdasarkan Kecenderungan Pengguna:
    - Mayoritas puas: Dominasi rating 5 menunjukkan bahwa pengguna cenderung puas atau sangat puas terhadap produk atau layanan yang mereka terima.
    - Peningkatan potensi kualitas: Rating 2 yang tinggi menunjukkan adanya kelompok signifikan pengguna yang tidak puas. Ini dapat menjadi indikasi untuk memperbaiki produk atau layanan.
    - Kurangnya ulasan ekstrem negatif: Jumlah rating 1 yang sangat kecil menunjukkan bahwa kasus ketidakpuasan ekstrim jarang terjadi, yang merupakan hal positif.

Blok kode dibawah ditujukan untuk melakukn visualisasi terhadap kolom 'category' pada dataframe user_revies. hal ini dilakukan untuk meninjau produk mana yang paling banyak terjual dan mendapatkan review
"""

# Get the category counts in descending order
category_order = user_reviews['category'].value_counts().index

# Create the countplot with categories sorted by frequency
plt.figure(figsize=(12, 6))
ax = sns.countplot(x='category', data=user_reviews, palette='Set2', order=category_order)

# Add title and labels
plt.title('Product Category Being Reviewed Frecuency', fontsize=18)
plt.xlabel('')
plt.ylabel('Count', fontsize=14)

# Rotate the x-axis labels for better visibility (if the category names are long)
plt.xticks(rotation=45, ha='right')

# Add value labels on top of each bar
for p in ax.patches:
    ax.text(
        p.get_x() + p.get_width() / 2,  # X position (center of each bar)
        p.get_height() + 0.2,  # Y position (slightly above the bar)
        f'{int(p.get_height())}',  # The value to display
        ha='center',  # Center the text horizontally
        fontsize=12,  # Font size
        color='black'  # Text color
    )

# Display the plot
plt.tight_layout()
plt.show()

"""**Observasi:**
- Kategori paling populer: Sarana dan Peralatan Irigasi adalah kategori yang paling sering diulas/terjual, dengan total 19.883 ulasan. Hal ini menunjukkan tingginya permintaan terhadap produk-produk terkait irigasi. Alat dan Mesin Pertanian berada di peringkat kedua dengan 19.765 ulasan. Perlengkapan Rumah Kaca dan Pembibitan berada di posisi ketiga dengan 18.145 ulasan. Kedua kategori ini menunjukkan popularitas produk-produk yang mendukung kegiatan pertanian secara langsung.
- Kategori dengan Jumlah Ulasan Sedang: 'Produk Olahan Pertanian', Kategori ini memiliki 17.515 ulasan, mencerminkan permintaan yang cukup signifikan untuk produk-produk yang telah diolah. 'Produk Pertanian Segar': Dengan 16.285 ulasan, kategori ini menunjukkan bahwa konsumen juga tertarik pada hasil pertanian yang segar. 'Teknologi Pertanian': Memiliki 14.920 ulasan, menandakan minat terhadap inovasi teknologi dalam bidang pertanian.
- Kategori dengan Jumlah Ulasan Rendah, 'Bibit dan Benih Tanaman': Dengan hanya 696 ulasan, kategori ini menjadi yang paling sedikit diulas. Hal ini menunjukkan permintaan yang relatif rendah dibandingkan kategori lain. 'Pupuk dan Nutrisi Tanaman': Kategori ini memiliki 12.587 ulasan, menempatkannya dalam kelompok dengan permintaan sedang.
- Ketimpangan Distribusi: Terdapat perbedaan besar antara kategori dengan jumlah ulasan tertinggi (Sarana dan Peralatan Irigasi) dan terendah (Bibit dan Benih Tanaman). Hal ini mencerminkan perbedaan fokus konsumen terhadap jenis produk yang dibutuhkan atau diminati.

## Bivariate Analysis

Blok kode dibawah ditujukan untuk melakukan visualisasi terhadap frekuensi review yang diterima oleh top 5 category product paling banyak terjual
"""

category_review_counts = user_reviews.groupby('category').size().reset_index(name='review_count')
top_5_categories = category_review_counts.nlargest(5, 'review_count')['category']

# Filter the DataFrame for only these top 5 categories
top_5_data = user_reviews[user_reviews['category'].isin(top_5_categories)]

# Group by category and rating to count rating frequencies
rating_frequencies = top_5_data.groupby(['category', 'rating']).size().reset_index(name='count')

# Pivot the DataFrame for side-by-side bar chart
rating_frequencies_pivot = rating_frequencies.pivot(index='category', columns='rating', values='count').fillna(0)

# Add a column for total reviews for sorting
rating_frequencies_pivot['total_reviews'] = rating_frequencies_pivot.sum(axis=1)

# Sort categories by total reviews (descending)
rating_frequencies_pivot = rating_frequencies_pivot.sort_values(by='total_reviews', ascending=False)

# Plotting
fig, ax = plt.subplots(figsize=(14, 8))

# Create side-by-side bar chart
bar_width = 0.15
categories = rating_frequencies_pivot.index
x = range(len(categories))

colors = sns.color_palette('viridis', n_colors=5)

# Loop through each rating (1-5) to plot
for i, rating in enumerate(rating_frequencies_pivot.columns[:-1]):
    ax.bar(
        [pos + i * bar_width for pos in x],
        rating_frequencies_pivot[rating],
        bar_width,
        label=f'Rating {rating}',
        color=colors[i]
    )
    # Add text above bars
    for pos, val in enumerate(rating_frequencies_pivot[rating]):
        if val > 0:
            ax.text(pos + i * bar_width, val + 5, int(val), ha='center', fontsize=12)

# Add total reviews in the middle of each category
for pos, total in enumerate(rating_frequencies_pivot['total_reviews']):
    ax.text(pos + 2.4 * bar_width, 2200, f"{int(total)}\nProduk Terjual", ha='center', fontsize=13, fontweight='bold')

# Customize chart
ax.set_xticks([pos + 2 * bar_width for pos in x])
ax.set_xticklabels(categories, rotation=20, fontsize=13, ha='right')
ax.set_title('Top 5 Categories: Rating Frequencies and Total Reviews', fontsize=16, pad=20)
ax.set_xlabel('Category', fontsize=12)
ax.set_ylabel('Frequency of Ratings', fontsize=12)
ax.legend(title='Rating', fontsize=10)
ax.grid(axis='y', linestyle='--', alpha=0.7)

# Adjust layout and show
plt.tight_layout()
plt.show()

"""**Observasi:**

**1. Alat dan Mesin Pertanian:**
- **Rating tertinggi (4 dan 5):**
  - Rating **4** dan **5** mendominasi kategori ini, masing-masing dengan **5.751** dan **4.730** ulasan, menunjukkan tingkat kepuasan yang cukup tinggi di antara konsumen.
- **Rating sedang (3):**
  - Rating **3** memiliki **3.734** ulasan, yang mencerminkan adanya konsumen dengan pengalaman netral.
- **Rating rendah (1 dan 2):**
  - Rating **2** mencapai **5.528**, cukup signifikan, sedangkan **rating 1** hanya ada **22** ulasan.


**2. Perlengkapan Rumah Kaca dan Pembibitan:**
- **Rating tertinggi (5):**
  - Rating **5** menjadi yang paling dominan, dengan **5.832** ulasan, mencerminkan produk ini sangat disukai konsumen.
- **Rating sedang (3 dan 4):**
  - **4.301** ulasan untuk rating **3** dan **4.100** ulasan untuk rating **4**, menunjukkan bahwa sebagian konsumen merasa puas atau netral.
- **Rating rendah (1 dan 2):**
  - Rating **2** memiliki **3.888** ulasan, sedangkan rating **1** hanya **24**, menunjukkan tingkat ketidakpuasan yang rendah.


**3. Produk Olahan Pertanian:**
- **Rating tertinggi (5):**
  - Rating **5** memiliki **4.994** ulasan, menjadi yang paling banyak di kategori ini.
- **Rating sedang (3 dan 4):**
  - Rating **4** mencatat **4.305** ulasan, sementara rating **3** memiliki **3.420** ulasan.
- **Rating rendah (1 dan 2):**
  - Rating **2** cukup tinggi dengan **4.782** ulasan, tetapi rating **1** sangat sedikit, hanya **14** ulasan.

**4. Produk Pertanian Segar:**
- **Rating tertinggi (5):**
  - Dengan **4.481** ulasan untuk rating **5**, kategori ini menunjukkan tingkat kepuasan yang tinggi di antara konsumen.
- **Rating sedang (3 dan 4):**
  - Rating **4** memiliki **3.246** ulasan, sementara rating **3** ada **3.707** ulasan.
- **Rating rendah (1 dan 2):**
  - Rating **2** tercatat sebanyak **4.817**, sedangkan rating **1** hanya **34**.

**5. Sarana dan Peralatan Irigasi:**
- **Rating tertinggi (5):**
  - Rating **5** mendominasi kategori ini dengan **5.970** ulasan, menunjukkan bahwa produk ini sangat dihargai.
- **Rating sedang (3 dan 4):**
  - Rating **3** memiliki **5.154** ulasan, sementara rating **4** mencatat **4.030** ulasan.
- **Rating rendah (1 dan 2):**
  - Rating **2** mencapai **4.693**, sedangkan rating **1** adalah yang paling sedikit, hanya **36** ulasan.


- **Kesimpulan Umum:**
> Dari kelima kategori produk, sebagian besar ulasan menunjukkan rating tinggi (**4 dan 5**), yang mencerminkan tingkat kepuasan konsumen yang baik secara keseluruhan. Namun, terdapat pula jumlah ulasan yang signifikan dengan rating **2**, terutama pada kategori **Alat dan Mesin Pertanian**, **Produk Olahan Pertanian**, dan **Sarana dan Peralatan Irigasi**, yang mengindikasikan bahwa ada ruang untuk perbaikan kualitas produk atau layanan pada kategori-kategori tersebut.

# Data Preprocessing

## Handle Null value

Blok kode dibawah ditujukan untuk melihat nilai null value yang munkin terdapat pada dataframe product
"""

product.isna().sum()

"""Didapati bahwa terdapat satu null values pada kolom 'productdescription', yang ditampilkan dengan blok kode berikut"""

product[product['productdescription'].isna()]

"""Blok kode dibawah ditujukan untuk meninjau produk yang dijual oleh toko Mahmud Storee untuk meninjau lebih lanjut produk yang memiliki nilai null"""

product[product['sellerid']=='Mahmud Storee']

"""Karena hanya terdapat satu product dengan nilai null value, sehingga 'productdescription' dengan nilai null value tersebut diisi dengan string deskripsi produk secara sederhana saja, tanpa perlu dihapus karena untuk proyek kali ini fitur 'productdescription' belum digunakan, akan tetapi munkin digunakan untuk pengembangan projek kedepannya."""

product['productdescription'] = product['productdescription'].fillna('pot tanaman')

"""Blok kode dibawah ditujukan untuk melihat nilai null pada dataframe product setelah dilakukan handling null values, didapati bahwa tidak ditemukan kembali nilai null"""

product.isna().sum()

"""Blok kode dibawah ditujukan untuk meninjau nilai null value pada dataframe user_reviews, didapati bahwa yidak ditemukannya nilai null"""

user_reviews.isna().sum()

"""## Handle Duplicate

Blok kode dibawah ditujukan untuk melihat nilai duplikat yang terdapat pada dataframe product. **Ditemukan 4 data duplikat**
"""

product.duplicated().sum()

"""Blok kode dibawah ditujukan untuk meninjau baris duplikat pada dataframe product"""

product[product.duplicated(keep=False)]

"""Blok dibawah ditujukan untuk handling baris duplikat pada dataframe product dengan melakukan drop duplicate"""

product = product.drop_duplicates()

"""Blok kode dibawah ditujukan untuk meninjaau kembali data duplikat pada dataframe product setelah dilakukan handling duplicate. **Tidak ditemukan data duplicate**"""

product.duplicated().sum()

"""Blok kode dibawah ditujukan untuk meninjau nilai duplikat pada dataframe user_reviews. Ditemukan 1843 nilai duplikat"""

user_reviews.duplicated().sum()

"""Blok kode dibawah ditujukan untuk meninjau baris data duplikat pada dataframe user_reviews. Didapati bahwa data duplikat munkin terjadi karena setiap user telah melakukan pembelian produk secara berulang, karena tidak adanya pencatatan waktu, maka nilai duplikat dibiarkan tanpa dilakukan handling apapun"""

user_reviews[user_reviews.duplicated(keep=False)]

"""## Handle Miss-spelling

Blok kode dibawah ditujukan untuk meninjau category yang ada pada dataframe product
"""

product.category.unique()

"""Blok kode dibawah ditujukan untuk meninjau category yang ada pada dataframe user_reviews"""

user_reviews.category.unique()

"""Didapati bahwa ada satu jenis kategori yang berbeda yaitu, untuk kategori "Pestisida dan Obat tanaman" pada dataframe product terhadap kategori 'Pestisida & Obat Pertanian" pada dataframe user_reviews. maka dilakukan perubahan pada dataframe user_reviews dengan penyesuaian menggunakan dataframe product"""

# Mengantikan 'Pestisida & Obat Pertanian' dengan 'Pestisida dan Obat tanaman' in the 'category' column
user_reviews['category'] = user_reviews['category'].replace('Pestisida & Obat Pertanian', 'Pestisida dan Obat tanaman')

"""# Model Development

## Content-Based Filtering

**Melakukan seleksi fitur untuk Mengembangkan sistem rekomendasi dengan Content-Based Filtering**
"""

product.sample(3)

"""Blok kode dibawah ditujukan untuk menyalin data berupa kolom 'productname' dan 'category'. kedua fitur ini dipilih karena pada proyek ini sistem rekomendasi produk dilakukan berdasarkan kategori produk"""

cbf_product = product[['productname', 'category']]

"""Blok kode dibawah ditujukan untuk melakukan **Stop Word Removal** pada kolom kategori untuk selanjutnya dilakukan vektorisasi"""

# menghilangkan 'dan' dari setiap category pada kolom 'category'
cbf_product['category'] = cbf_product['category'].str.replace(r'\bdan\b', '', regex=True)

# Check the updated categories
cbf_product['category'].value_counts()

"""Blok kode dibawah ditujukan untuk melkukan vektorisasi pada kolom 'category' yang nantinya dijadikan dasar untuk sistem rekomendasi"""

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data category
tf.fit(cbf_product['category'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

"""Blok kode dibawah ditujukan untuk melakukan fit vectorizer terhadap data lalu ditransformasikan ke bentuk matrix, dan kemudian ditinjau dimensi dari hasil akhir transformasi yang dilakukan"""

tfidf_matrix = tf.fit_transform(cbf_product['category'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

"""Blok kode dibawah ditujukan untuk mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()"""

tfidf_matrix.todense()

"""Blok kode dibawah ini ditujukan untuk membuat dataframe guna melihat tf-idf matrix
- Kolom diisi dengan kategori produk
- Baris diisi dengan nama produk
"""

matrix_tfidf = pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=cbf_product.productname
).sample(22, axis=1).sample(10, axis=0)
matrix_tfidf

"""Blok kode dibawah ditujukan untuk menghitung nilai cosine similarity berdasarkan matrix tf-idf"""

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Blok kode dibawah ditujukan untuk membuat dataframe baru yang berisi hasil pemrosesan hitung cosine similarity, yang nantinya akan digunakan untuk membuat rekomendasi"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama resto
cosine_sim_df = pd.DataFrame(cosine_sim, index=cbf_product['productname'], columns=cbf_product['productname'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap product
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Blok kode dibawah ditujukan untuk menghitung metrik evaluasi terhadap hasil perhitungan cosine similarity untuk meninjau ke-akuratan rekomendasi yang dibuat"""

# Placeholder for ground truth similarity
ground_truth_sim = pd.DataFrame(0, index=cosine_sim_df.index, columns=cosine_sim_df.columns)

# Populate ground truth based on category
for product1 in cbf_product['productname']:
    for product2 in cbf_product['productname']:
        if cbf_product.loc[cbf_product['productname'] == product1, 'category'].values[0] == \
           cbf_product.loc[cbf_product['productname'] == product2, 'category'].values[0]:
            ground_truth_sim.loc[product1, product2] = 1  # Same category -> Perfect similarity

# Flatten matrices for comparison
predicted = cosine_sim_df.values.flatten()
ground_truth = ground_truth_sim.values.flatten()


mse = mean_squared_error(ground_truth, predicted)
rmse = np.sqrt(mean_squared_error(ground_truth, predicted))
mae = mean_absolute_error(ground_truth, predicted)

print(f"Mean Absolut Error (MAE): {mae}")
print(f"Mean Squared Error (MSE): {mse}")
print(f"Root Mean Squared Error (RMSE): {rmse}")

"""Blok kode dibawah ditujukan untuk membuat fungsi yang akan menghasilkan top-n produk rekomendasi berdasarkan  nama produk yang diingin kan"""

def product_recommendations(nama_produk, similarity_data=cosine_sim_df, items=cbf_product[['productname', 'category']], top=5):
    """
    Rekomendasi Produk berdasarkan kemiripan dataframe, termasuk skor kemiripan.

    Parameter:
    ---
    nama_produk : tipe data string (str)
                Nama Produk (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan produk sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    top : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---

    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """

    # Mengambil data similarity untuk produk yang diberikan
    sim_scores = similarity_data.loc[nama_produk]

    # Mengambil produk-produk dengan similarity terbesar
    # Sort the similarity scores in descending order and exclude the input product itself
    sorted_sim_scores = sim_scores.sort_values(ascending=False)

    # Exclude the input product itself (remove it from the recommendations)
    sorted_sim_scores = sorted_sim_scores.drop(nama_produk, errors='ignore')

    # Select the top N recommendations
    top_recommendations = sorted_sim_scores.head(top)

    # Merge the recommendations with the items DataFrame to get additional details (e.g., category)
    recommendations = top_recommendations.to_frame(name="Similarity Score").merge(
        items, left_index=True, right_on='productname', how='left'
    )

    # Reset the index of the resulting DataFrame
    recommendations = recommendations.reset_index(drop=True)

    print(f"Top {top} Rekomendasi Produk dengan Skor Kemiripan:")
    return recommendations

"""Blok kode dibawah ditujukan untuk melihat nama salah satu produk yang tersedia. hal ini dilakukan untuk mengambil nama produk tersebut dan nantinya akan dicoba untuk dilihat rekomendasi yang bersesuaian dengan produk tersebut"""

cbf_product.productname[23]

"""blok kode dibawah ditujukan untuk melihat baris data nama produk yang akan dipilih"""

cbf_product[cbf_product.productname.eq('Booster Pump Waterplus BR 220 DPA Mesin Pendorong Air Otomatis')]

"""Blok kode dibawah ditujukan untuk mendapatkan rekomendasi berdasarkan produk 'Booster Pump Waterplus BR 220 DPA Mesin Pendorong Air Otomatis' (dengan nilai top= default yakni top 5 produk rekomendasi)"""

# Mendapatkan rekomendasi produk yang mirip
product_recommendations('Booster Pump Waterplus BR 220 DPA Mesin Pendorong Air Otomatis')

"""Blok kode dibawah ditujukan untuk mendapatkan rekomendasi berdasarkan produk 'Booster Pump Waterplus BR 220 DPA Mesin Pendorong Air Otomatis' (dengan nilai top= default yakni top 7 produk rekomendasi)"""

# Mendapatkan rekomendasi produk yang mirip
product_recommendations('Booster Pump Waterplus BR 220 DPA Mesin Pendorong Air Otomatis', top=7)

"""Blok kode dibawah ditujukan untuk mendapatkan rekomendasi berdasarkan produk '100ml Pestisida Organik Neem Oil /Minyak Mimba dari Biosfer Organik' (dengan nilai top= default yakni top 5 produk rekomendasi)"""

# Mendapatkan rekomendasi produk yang mirip dengan produk pestisida
product_recommendations('100ml Pestisida Organik Neem Oil /Minyak Mimba dari Biosfer Organik')

"""Blok kode dibawah ditujukan untuk membuat fungsi yang digunakan untuk melakukan perhitungan metrik evaluation berbasis relevansi rekomendasi. Pada proyek ini digunakan precision@K dan NDCG@K"""

def precision_at_k(recommended_items, relevant_items, k):
    """
    Calculate Precision@K.

    Parameters:
    ---
    recommended_items : list
        List of recommended product names.
    relevant_items : list
        List of relevant product names.
    k : int
        Number of top recommendations to consider.

    Returns:
    ---
    float
        Precision@K value.
    """
    recommended_at_k = recommended_items[:k]  # Top-K recommendations
    relevant_at_k = set(recommended_at_k) & set(relevant_items)  # Intersection of recommended and relevant items
    return len(relevant_at_k) / k

def ndcg_at_k(recommended_items, relevant_items, k):
    """
    Calculate NDCG@K.

    Parameters:
    ---
    recommended_items : list
        List of recommended product names.
    relevant_items : list
        List of relevant product names.
    k : int
        Number of top recommendations to consider.

    Returns:
    ---
    float
        NDCG@K value.
    """
    recommended_at_k = recommended_items[:k]  # Top-K recommendations

    # Compute DCG@K
    dcg = 0.0
    for i, item in enumerate(recommended_at_k):
        if item in relevant_items:
            dcg += 1 / np.log2(i + 2)  # i+2 because index starts at 0 and log(1) is undefined

    # Compute IDCG@K
    ideal_relevant_count = min(len(relevant_items), k)
    idcg = sum(1 / np.log2(i + 2) for i in range(ideal_relevant_count))

    return dcg / idcg if idcg > 0 else 0.0

"""Blok kode dibawah digunakan untuk menghitung metric evaluasi precision@K dan NDCG@K terhadap rekomendasi untuk item "100ml Pestisida Organik Neem Oil /Minyak Mimba dari Biosfer Organik"
"""

input_product = "100ml Pestisida Organik Neem Oil /Minyak Mimba dari Biosfer Organik"

# Get recommended items
recommendations = product_recommendations(input_product, top=5)
recommended_items = recommendations['productname'].tolist()

# Define relevant items
input_category = cbf_product[cbf_product['productname'] == input_product]['category'].values[0]
relevant_items = cbf_product[cbf_product['category'] == input_category]['productname'].tolist()
relevant_items = [item for item in relevant_items if item != input_product]

# Calculate metrics
k = 5
precision = precision_at_k(recommended_items, relevant_items, k)
ndcg = ndcg_at_k(recommended_items, relevant_items, k)

# Print results
print(f"Precision@{k}: {precision:.4f}")
print(f"NDCG@{k}: {ndcg:.4f}")
recommendations

"""Didapati bahwa nilai precision@K  bernilai 80% dan NDCG@K bernilai 100% menunjukkan hasil yang cukup baik terhadap model yang dibuat

## Collaborative Filtering

Blok kode dibawah ditujukan untuk membuat pivot table guna mendapatkan metrix antara user dan produk terhadap nilai rating yang diberikan untuk tiap produk, serta mengisi nilai yang nan dengan nilai 0, yang menunjukan user belum pernah membeli produk
"""

# Create user-product matrix (rows: users, columns: products, values: ratings)
user_product_matrix = user_reviews.pivot_table(index='user_id', columns='productname', values='rating')

# Fill NaN values with 0 (meaning no interaction/rating for that user-product pair)
user_product_matrix = user_product_matrix.fillna(0)
user_product_matrix

"""Setelah didapatkan metrix, selanjutnya blok kode di bawah ditujukan untuk melakukan perhitungan **matrix factorization menggunakan metode SVD**, sedikit *overview* mengenai **Singular Value Decomposition (SVD)**;

SVD adalah metode dekomposisi matriks yang memecah sebuah matriks R (misalnya matriks rating user-produk) menjadi tiga matriks:

$$R = U \cdot \Sigma \cdot V^T$$

1.  **U** (User Matrix): Representasi fitur laten pengguna.
2.  **Σ** (Singular Value Matrix): Matriks diagonal yang mengandung *singular values*, yang menunjukkan kepentingan setiap fitur laten.
3.  **V<sup>T</sup>** (Item Matrix): Representasi fitur laten item.

### Implementasi dalam Collaborative Filtering

1.  **Input Data**:
    *   Matriks rating ($R$), di mana baris merepresentasikan pengguna dan kolom merepresentasikan item. Nilai dalam matriks adalah rating yang diberikan oleh pengguna terhadap item.
    *   Jika ada nilai yang kosong (*missing values*), biasanya diisi dengan nilai rata-rata atau dibiarkan kosong dalam beberapa implementasi.

2.  **Reduksi Dimensi**:
    *   SVD memecah matriks $R$ menjadi tiga matriks, namun kita dapat memilih hanya beberapa *singular values* teratas dari $Σ$ untuk mengurangi dimensi dan menangkap pola penting saja. Ini membantu dalam menangani data yang besar dan mengurangi *noise*.

3.  **Rekonstruksi Matriks**:
    *   Matriks $R'$, hasil perkalian $U$, $Σ$, dan ($V^T$), merepresentasikan prediksi rating yang bisa diberikan pengguna terhadap item. Jika ada nilai kosong di matriks awal ($R$) , nilai tersebut akan terisi dengan prediksi rating.

4.  **Prediksi**:
    *   Dari matriks rekonstruksi ($R'$), kita dapat memilih **Top-N Recommendation** untuk setiap pengguna berdasarkan prediksi rating tertinggi.
"""

# Convert the user-item matrix to a NumPy matrix
R = user_product_matrix.values

# Normalize the ratings by subtracting the mean user rating (centered data)
user_ratings_mean = np.mean(R, axis=1)
R_demeaned = R - user_ratings_mean.reshape(-1, 1)

# Apply Singular Value Decomposition (SVD)
U, sigma, Vt = svds(R_demeaned, k=50)  # k is the number of latent factors

# Convert sigma to a diagonal matrix
sigma = np.diag(sigma)

# Reconstruct the ratings matrix (predicted ratings)
predicted_ratings = np.dot(np.dot(U, sigma), Vt) + user_ratings_mean.reshape(-1, 1)

# Convert the predicted ratings back to a DataFrame
predicted_ratings_df = pd.DataFrame(predicted_ratings, columns=user_product_matrix.columns)

# Ensure that the user IDs are set as the index for predicted_ratings_df
predicted_ratings_df.index = user_product_matrix.index

"""Blok kode dibawah ditujukan untuk meninjau hasil dataframe matrix prediksi setelah dilakukan matrix factorization terhadap metrix user_product. dataframe ini yang dijadikan dasar untuk sistem rekomendasi collaborative filtering"""

print(predicted_ratings_df.shape)
predicted_ratings_df.head()

"""Blok kode dibawah ditunjukan untuk meninjau metrik evaluasi dari metode Collaborative Filtering menggunakan metode SVD"""

# Flatten the matrices for comparison
y_true = user_product_matrix.values.flatten()
y_pred = predicted_ratings.flatten()

# Filter out non-rated (zero values) for evaluation
non_zero_indices = y_true > 0
y_true_filtered = y_true[non_zero_indices]
y_pred_filtered = y_pred[non_zero_indices]

# Calculate evaluation
rmse = np.sqrt(mean_squared_error(y_true_filtered, y_pred_filtered))
mse = mean_squared_error(y_true_filtered, y_pred_filtered)
mae = mean_absolute_error(y_true_filtered, y_pred_filtered)

print(f"Mean Absolut Error (MAE): {mae}")
print(f"Mean Squared Error (MSE): {mse}")
print(f"Root Mean Squared Error (RMSE): {rmse}")

"""Selanjutnya Blok kode dibawah ditujukan untuk melakukan pengambilan sample data untuk dilakukan metrcs evaluation menggunakan metode yang berbasis relevansi rekomendasi"""

k = 10
sample_predictions = {
    user: predicted_ratings_df.loc[user].sort_values(ascending=False).head(k).index.tolist()
    for user in predicted_ratings_df.index
}

ground_truth = {
    user: ratings.sort_values(ascending=False).index.tolist()
    for user, ratings in user_product_matrix.iterrows()
}

"""Blok kode dibawah ditujukan untuk membuat fungsi perhitungan precision@K dan NDCG@K"""

def svd_precision_at_k(predicted, ground_truth, k):
    return len(set(predicted[:k]) & set(ground_truth[:k])) / k

def svd_ndcg_at_k(predicted, ground_truth, k):
    dcg = sum([1 / np.log2(idx + 2) for idx, item in enumerate(predicted[:k]) if item in ground_truth])
    idcg = sum([1 / np.log2(idx + 2) for idx in range(min(len(ground_truth), k))])
    return dcg / idcg if idcg > 0 else 0

"""Blok kode dibawah ditujukan untuk menentukan metrik precision@K dan NDCG@K berbasis relevansi rekomendasi untuk keseluruhan hasil rekomendasi pada top_k customer"""

precisionk = np.mean([precision_at_k(sample_predictions[user], ground_truth[user], k) for user in predicted_ratings_df.index])
ndcgk = np.mean([ndcg_at_k(sample_predictions[user], ground_truth[user], k) for user in predicted_ratings_df.index])

print(f'Precision@K: {precisionk}')
print(f'NCDG@K: {ndcgk}')

"""Didapati bahwa nilai precision@K dan NDCG@K bernilai 1, menunjukkan nilai evaluasi maksimum

Blok Kode dibawah ditujukan untuk membuat fungsi yang nantinya digunakan untuk memberikan rekomendasi berdasarkan input nama user atau user_id yang diberikan, dengan output beberapa top prodyuct yang bersesuaian untuk dijadikan rekomendasi terhadap input user
"""

def recommend_products(user_id, user_product_matrix=user_product_matrix, predicted_ratings_df=predicted_ratings_df, items=cbf_product, top=5):
    """
    Recommend top N products to a user based on predicted ratings.

    Parameters:
    - user_id: ID of the user for whom we want recommendations
    - user_product_matrix: Original user-item matrix (ratings matrix)
    - predicted_ratings_df: The matrix of predicted ratings after SVD
    - items: A DataFrame with product details (e.g., product names, categories)
    - top_n: Number of recommendations to return

    Returns:
    - A DataFrame of top N recommended products with predicted ratings
    """
    # Get the user's predicted ratings for products
    user_row = predicted_ratings_df.loc[user_id]

    # Sort the products by predicted rating in descending order
    recommended_products = user_row.sort_values(ascending=False)

    # Exclude products that the user has already rated (rated > 0)
    rated_products = user_product_matrix.loc[user_id]
    recommended_products = recommended_products.drop(rated_products[rated_products > 0].index)

    # Get top N recommendations
    top_recommended_products = recommended_products.head(top)

    # Create a DataFrame for the top N recommendations
    recommendations_df = pd.DataFrame({
        'Product Name': top_recommended_products.index,
        'Predicted Rating': top_recommended_products.values
    })

    # Merge with items DataFrame to get additional product information (e.g., category)
    recommendations_df = recommendations_df.merge(items[['category','productname']], left_on='Product Name', right_on='productname', how='left')
    recommendations_df = recommendations_df[['Product Name', 'category', 'Predicted Rating']]
    print(f'Top {top} Rekomendasi Produk untuk {user_id}:')
    return recommendations_df

"""Blok kode dibawah ditujukan untuk melakukan uji coba sistem rekomendasi collaborative filtering memnggunakan metode SVD untuk user 'Bambang"
"""

user_id = 'Bambang'
recommend_products(user_id, top=10)